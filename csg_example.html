<!DOCTYPE html>
<html lang="en">
<head>
    <title>Three.js CSG – Fixed & Stable</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; }
        #info {
            position: absolute; top: 20px; width: 100%;
            text-align: center; color: white; font-family: sans-serif;
            z-index: 10; pointer-events: none;
        }
    </style>
</head>
<body>
<div id="info">CSG Fixed — Real-Time Subtraction</div>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
    "three-bvh-csg": "https://unpkg.com/three-bvh-csg@0.0.16/build/index.module.js",
    "three-mesh-bvh": "https://unpkg.com/three-mesh-bvh@0.7.3/build/index.module.js"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { Brush, Evaluator, SUBTRACTION } from 'three-bvh-csg';

// ==================================================================
// 1. SCENE SETUP
// ==================================================================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222222);

const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(4, 4, 4);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);

// ==================================================================
// 2. LIGHTING
// ==================================================================
scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6));

const dirLight = new THREE.DirectionalLight(0xffffff, 2);
dirLight.position.set(5, 10, 5);
dirLight.castShadow = true;
scene.add(dirLight);

// ==================================================================
// 3. CSG BRUSH SETUP
// ==================================================================
const evaluator = new Evaluator();
evaluator.useGroups = false;
evaluator.keepMaterials = true;

// Brush A: BOX
const brushA = new Brush(
    new THREE.BoxGeometry(2, 2, 2),
    new THREE.MeshStandardMaterial({ color: 0x0088ff })
);
brushA.matrixAutoUpdate = false;

// Brush B: SPHERE (CUTTER)
const brushB = new Brush(
    new THREE.SphereGeometry(1.2, 32, 32),
    new THREE.MeshStandardMaterial({ color: 0xff0055, emissive: 0x220011 })
);
brushB.matrixAutoUpdate = false;

// Mesh output (REAL render)
const resultMesh = new THREE.Mesh();
resultMesh.castShadow = true;
resultMesh.receiveShadow = true;
scene.add(resultMesh);

// ==================================================================
// 4. ANIMATION LOOP
// ==================================================================
const clock = new THREE.Clock();

function animate() {
    requestAnimationFrame(animate);

    const t = clock.getElapsedTime();

    // Move sphere
    brushB.position.set(Math.sin(t) * 1.1, Math.cos(t * 0.5) * 0.5, 0);
    brushB.updateMatrixWorld(true);

    // Update box
    brushA.rotation.y = t * 0.2;
    brushA.updateMatrixWorld(true);

    // Compute boolean
    const result = evaluator.evaluate(brushA, brushB, SUBTRACTION);

    // Apply result (safe disposal)
    resultMesh.geometry.dispose();
    resultMesh.geometry = result.geometry;
    resultMesh.material = result.material;

    renderer.render(scene, camera);
}

animate();

// ==================================================================
// 5. HANDLE RESIZE
// ==================================================================
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
